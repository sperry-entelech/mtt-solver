import request from 'supertest';
import { createApp } from '../../src/index';
import express from 'express';

describe('Security - Vulnerability Scanning Tests', () => {
  let app: express.Application;

  beforeAll(async () => {
    app = createApp();
    await new Promise(resolve => setTimeout(resolve, 1000));
  });

  describe('OWASP Top 10 Security Tests', () => {
    describe('A01:2021 - Broken Access Control', () => {
      it('should prevent unauthorized access to admin endpoints', async () => {
        const adminEndpoints = [
          '/api/admin/users',
          '/api/admin/stats',
          '/api/admin/config',
          '/api/admin/logs'
        ];

        for (const endpoint of adminEndpoints) {
          const response = await request(app)
            .get(endpoint);

          // Should require authentication/authorization
          expect([401, 403, 404]).toContain(response.status);
        }
      });

      it('should prevent path traversal attacks', async () => {
        const pathTraversalAttempts = [
          '/api/../../../etc/passwd',
          '/api/hands/../../config/database.json',
          '/api/icm/../admin/users',
          '/api/ranges/push/../../../../secret.txt'
        ];

        for (const maliciousPath of pathTraversalAttempts) {
          const response = await request(app)
            .get(maliciousPath);

          // Should not access unauthorized files
          expect([400, 403, 404]).toContain(response.status);
        }
      });

      it('should prevent privilege escalation', async () => {
        // Test user trying to access admin functions
        const response = await request(app)
          .post('/api/admin/reset-database')
          .set('Authorization', 'Bearer user_token')
          .send({});

        expect([401, 403, 404]).toContain(response.status);
      });
    });

    describe('A02:2021 - Cryptographic Failures', () => {
      it('should use HTTPS in production headers', async () => {
        const response = await request(app)
          .get('/health')
          .expect(200);

        // Check for security headers
        expect(response.headers).toHaveProperty('strict-transport-security');
      });

      it('should not expose sensitive data in responses', async () => {
        const response = await request(app)
          .get('/api/hands/history')
          .set('X-Session-ID', 'test_session');

        if (response.status === 200) {
          const responseText = JSON.stringify(response.body);

          // Check for common sensitive data patterns
          expect(responseText).not.toMatch(/password/i);
          expect(responseText).not.toMatch(/secret/i);
          expect(responseText).not.toMatch(/private[_-]key/i);
          expect(responseText).not.toMatch(/database[_-]url/i);
          expect(responseText).not.toMatch(/api[_-]key/i);
        }
      });

      it('should handle encryption/decryption errors securely', async () => {
        const malformedEncryptedData = 'not_valid_encrypted_data';

        const response = await request(app)
          .post('/api/session/decrypt')
          .send({ data: malformedEncryptedData });

        // Should not expose decryption details
        if (response.status >= 400) {
          expect(response.body.error).not.toMatch(/decrypt|cipher|key/i);
        }
      });
    });

    describe('A03:2021 - Injection', () => {
      it('should prevent NoSQL injection in MongoDB queries', async () => {
        const noSqlInjection = {
          'cards.$where': 'function() { return true; }',
          'cards': { '$ne': null }
        };

        const response = await request(app)
          .post('/api/hands/search')
          .send(noSqlInjection);

        expect([400, 422]).toContain(response.status);
      });

      it('should prevent command injection', async () => {
        const commandInjection = '; cat /etc/passwd; echo';

        const response = await request(app)
          .post('/api/hands/evaluate')
          .send({
            cards: [
              { rank: 'A', suit: commandInjection },
              { rank: 'K', suit: 'h' },
              { rank: 'Q', suit: 'd' },
              { rank: 'J', suit: 'c' },
              { rank: 'T', suit: 's' }
            ]
          });

        expect(response.status).toBe(400);
      });

      it('should prevent LDAP injection', async () => {
        const ldapInjection = '*)(uid=*))(|(uid=*';

        const response = await request(app)
          .post('/api/auth/login')
          .send({
            username: ldapInjection,
            password: 'test123'
          });

        expect([400, 401, 404]).toContain(response.status);
      });
    });

    describe('A04:2021 - Insecure Design', () => {
      it('should implement proper business logic validation', async () => {
        // Test illogical tournament scenario
        const response = await request(app)
          .post('/api/icm/calculate')
          .send({
            stacks: [1000000], // Single player
            payouts: [500, 300, 200], // Multiple payouts
            playerIndex: 0
          });

        expect(response.status).toBe(400);
        expect(response.body.error).toMatch(/invalid|logic|scenario/i);
      });

      it('should prevent race conditions in calculations', async () => {
        const calculateRequest = {
          stacks: [2000, 1500, 1000],
          payouts: [5000, 3000, 2000],
          playerIndex: 0
        };

        // Make multiple simultaneous requests
        const promises = Array(10).fill(null).map(() =>
          request(app)
            .post('/api/icm/calculate')
            .send(calculateRequest)
        );

        const responses = await Promise.all(promises);

        // All should return consistent results
        const validResponses = responses.filter(r => r.status === 200);
        if (validResponses.length > 1) {
          const firstResult = validResponses[0].body.equity;
          validResponses.forEach(response => {
            expect(Math.abs(response.body.equity - firstResult)).toBeLessThan(0.01);
          });
        }
      });
    });

    describe('A05:2021 - Security Misconfiguration', () => {
      it('should have proper security headers', async () => {
        const response = await request(app)
          .get('/health')
          .expect(200);

        // Essential security headers
        expect(response.headers).toHaveProperty('x-content-type-options', 'nosniff');
        expect(response.headers).toHaveProperty('x-frame-options');
        expect(response.headers).toHaveProperty('x-xss-protection');
        expect(response.headers).toHaveProperty('referrer-policy');
      });

      it('should not expose server information', async () => {
        const response = await request(app)
          .get('/health');

        // Should not expose server technology details
        expect(response.headers).not.toHaveProperty('x-powered-by');
        expect(response.headers.server).not.toMatch(/express|node/i);
      });

      it('should disable unnecessary HTTP methods', async () => {
        const unnecessaryMethods = ['TRACE', 'OPTIONS', 'CONNECT'];

        for (const method of unnecessaryMethods) {
          const response = await request(app)[method.toLowerCase()]?.('/api/hands/evaluate');

          if (response) {
            expect([405, 501]).toContain(response.status);
          }
        }
      });

      it('should not expose debug information', async () => {
        const response = await request(app)
          .get('/api/debug')
          .expect([404, 403]); // Should not exist or be accessible

        if (response.status === 200) {
          // If debug endpoint exists, should require authentication
          expect(response.body).not.toHaveProperty('environment');
          expect(response.body).not.toHaveProperty('config');
        }
      });
    });

    describe('A06:2021 - Vulnerable Components', () => {
      it('should not expose component versions', async () => {
        const response = await request(app)
          .get('/health');

        const responseText = JSON.stringify(response.body) + JSON.stringify(response.headers);

        // Should not expose version information
        expect(responseText).not.toMatch(/version.*\d+\.\d+\.\d+/i);
        expect(responseText).not.toMatch(/express.*\d+/i);
        expect(responseText).not.toMatch(/node.*\d+/i);
      });
    });

    describe('A07:2021 - Identification and Authentication Failures', () => {
      it('should implement account lockout after failed attempts', async () => {
        const loginAttempts = Array(10).fill(null).map(() =>
          request(app)
            .post('/api/auth/login')
            .send({
              username: 'testuser',
              password: 'wrongpassword'
            })
        );

        const responses = await Promise.all(loginAttempts);

        // Should eventually lock account or implement rate limiting
        const lastFewResponses = responses.slice(-3);
        const hasLockout = lastFewResponses.some(r =>
          r.status === 429 ||
          (r.status === 400 && r.body.error?.includes('locked'))
        );

        expect(hasLockout).toBe(true);
      });

      it('should not reveal username existence', async () => {
        const responses = await Promise.all([
          request(app)
            .post('/api/auth/login')
            .send({ username: 'existing_user', password: 'wrong' }),
          request(app)
            .post('/api/auth/login')
            .send({ username: 'nonexistent_user', password: 'wrong' })
        ]);

        // Error messages should be similar for existing and non-existing users
        if (responses[0].status === 401 && responses[1].status === 401) {
          expect(responses[0].body.error).toBe(responses[1].body.error);
        }
      });
    });

    describe('A08:2021 - Software and Data Integrity Failures', () => {
      it('should validate input data integrity', async () => {
        const tamperedData = {
          cards: [
            { rank: 'A', suit: 's' },
            { rank: 'K', suit: 'h' },
            { rank: 'Q', suit: 'd' },
            { rank: 'J', suit: 'c' },
            { rank: 'T', suit: 's' }
          ],
          checksum: 'invalid_checksum'
        };

        const response = await request(app)
          .post('/api/hands/evaluate')
          .send(tamperedData);

        // Should validate data integrity if checksums are used
        if (response.status === 400) {
          expect(response.body.error).toMatch(/integrity|checksum|invalid/i);
        }
      });
    });

    describe('A09:2021 - Security Logging and Monitoring Failures', () => {
      it('should log security events without sensitive data', async () => {
        // Trigger a security event
        await request(app)
          .post('/api/hands/evaluate')
          .send({
            cards: [{ rank: "'; DROP TABLE users; --", suit: 's' }]
          })
          .expect(400);

        // In a real test, you would check log files
        // This is a placeholder for log validation
        expect(true).toBe(true); // Placeholder assertion
      });

      it('should handle failed requests appropriately', async () => {
        const response = await request(app)
          .post('/api/nonexistent')
          .send({})
          .expect(404);

        // Should provide appropriate error responses
        expect(response.body).toHaveProperty('error');
        expect(response.body).toHaveProperty('timestamp');
      });
    });

    describe('A10:2021 - Server-Side Request Forgery (SSRF)', () => {
      it('should prevent SSRF attacks in URL parameters', async () => {
        const ssrfUrls = [
          'http://localhost:22',          // Internal SSH
          'http://169.254.169.254/',      // AWS metadata
          'http://metadata.google.internal/', // GCP metadata
          'file:///etc/passwd',           // File protocol
          'ftp://internal.server/',       // FTP protocol
        ];

        for (const maliciousUrl of ssrfUrls) {
          const response = await request(app)
            .post('/api/external/fetch')
            .send({ url: maliciousUrl });

          expect([400, 403, 422]).toContain(response.status);
        }
      });

      it('should validate and whitelist external URLs', async () => {
        const response = await request(app)
          .post('/api/external/validate')
          .send({ url: 'http://evil-site.com/malicious' });

        expect([400, 403]).toContain(response.status);
      });
    });
  });

  describe('Additional Security Tests', () => {
    describe('Content Security Policy', () => {
      it('should implement CSP headers', async () => {
        const response = await request(app)
          .get('/health');

        // Check for CSP header
        const csp = response.headers['content-security-policy'];
        if (csp) {
          expect(csp).toMatch(/default-src/);
          expect(csp).not.toMatch(/unsafe-inline/);
        }
      });
    });

    describe('Session Security', () => {
      it('should use secure session cookies', async () => {
        const response = await request(app)
          .post('/api/session/create')
          .send({});

        const setCookie = response.headers['set-cookie'];
        if (setCookie) {
          const cookieString = Array.isArray(setCookie) ? setCookie[0] : setCookie;
          expect(cookieString).toMatch(/HttpOnly/i);
          expect(cookieString).toMatch(/Secure/i);
          expect(cookieString).toMatch(/SameSite/i);
        }
      });

      it('should regenerate session IDs after authentication', async () => {
        // Create initial session
        const initialResponse = await request(app)
          .post('/api/session/create')
          .send({});

        const initialSessionId = initialResponse.body.sessionId;

        // Authenticate (mock)
        const authResponse = await request(app)
          .post('/api/auth/login')
          .set('X-Session-ID', initialSessionId)
          .send({ username: 'test', password: 'test' });

        if (authResponse.status === 200) {
          const newSessionId = authResponse.body.sessionId;
          expect(newSessionId).not.toBe(initialSessionId);
        }
      });
    });

    describe('Input Sanitization', () => {
      it('should sanitize HTML in all text inputs', async () => {
        const htmlPayloads = [
          '<script>alert("xss")</script>',
          '<img src="x" onerror="alert(1)">',
          '<svg onload="alert(1)">',
          'javascript:alert(1)',
          'data:text/html,<script>alert(1)</script>'
        ];

        for (const payload of htmlPayloads) {
          const response = await request(app)
            .post('/api/hands/evaluate')
            .send({
              cards: [
                { rank: 'A', suit: 's', description: payload },
                { rank: 'K', suit: 'h' },
                { rank: 'Q', suit: 'd' },
                { rank: 'J', suit: 'c' },
                { rank: 'T', suit: 's' }
              ]
            });

          if (response.status === 200) {
            const responseText = JSON.stringify(response.body);
            expect(responseText).not.toContain('<script>');
            expect(responseText).not.toContain('javascript:');
            expect(responseText).not.toContain('onerror=');
          }
        }
      });
    });

    describe('API Security', () => {
      it('should implement proper CORS configuration', async () => {
        const response = await request(app)
          .options('/api/hands/evaluate')
          .set('Origin', 'https://malicious-site.com')
          .set('Access-Control-Request-Method', 'POST');

        // Should not allow arbitrary origins
        expect(response.headers['access-control-allow-origin']).not.toBe('*');
      });

      it('should validate API key format if required', async () => {
        const invalidApiKeys = [
          'short',
          '',
          'key-with-spaces ',
          'key\nwith\nnewlines',
          'key;with;semicolons'
        ];

        for (const apiKey of invalidApiKeys) {
          const response = await request(app)
            .post('/api/hands/evaluate')
            .set('X-API-Key', apiKey)
            .send({
              cards: [
                { rank: 'A', suit: 's' },
                { rank: 'K', suit: 'h' },
                { rank: 'Q', suit: 'd' },
                { rank: 'J', suit: 'c' },
                { rank: 'T', suit: 's' }
              ]
            });

          if (response.status === 401) {
            expect(response.body.error).toMatch(/api.?key|authentication/i);
          }
        }
      });
    });

    describe('Denial of Service Protection', () => {
      it('should limit concurrent connections', async () => {
        const concurrentRequests = Array(100).fill(null).map(() =>
          request(app)
            .post('/api/hands/evaluate')
            .send({
              cards: [
                { rank: 'A', suit: 's' },
                { rank: 'K', suit: 'h' },
                { rank: 'Q', suit: 'd' },
                { rank: 'J', suit: 'c' },
                { rank: 'T', suit: 's' }
              ]
            })
        );

        const responses = await Promise.all(concurrentRequests);

        // Some requests should be rate limited or rejected
        const rateLimited = responses.filter(r => r.status === 429 || r.status === 503);
        expect(rateLimited.length).toBeGreaterThan(0);
      });

      it('should have request timeout protection', async () => {
        // Test with a request that might take a long time
        const startTime = Date.now();

        const response = await request(app)
          .post('/api/hands/equity')
          .send({
            hand1: [{ rank: 'A', suit: 's' }, { rank: 'K', suit: 'h' }],
            hand2: [{ rank: 'Q', suit: 'c' }, { rank: 'J', suit: 'd' }],
            iterations: 1000000 // Very high iteration count
          });

        const endTime = Date.now();
        const duration = endTime - startTime;

        // Should either complete quickly or timeout appropriately
        if (response.status === 408 || response.status === 503) {
          expect(duration).toBeLessThan(30000); // 30 second timeout
        }
      });
    });
  });
});